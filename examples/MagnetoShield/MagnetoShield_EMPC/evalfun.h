/* The function for evaluation of a piecewise affine control law associated
   to a given state X using sequential search.

  Usage:
   unsigned long region = ectrl( float *X, float *U)


   where X is a vector of dimension MPT_DOMAIN and U is a vector of dimension 
   MPT_RANGE for PWA functions ( 1 for PWQ functions). The output variable "region"
   indicates index of a region where the point X is located. If "region" index is
   smaller than 1 (region < 1), there is no control law associated to
   a given state.

   Please note that all code in this file is provided under the terms of the
   GNU General Public License, which implies that if you include it directly
   into your commercial application, you will need to comply with the license.
   If you feel this is not a good solution for you or your company, feel free 
   to contact the author:
       michal.kvasnica@stuba.sk
    to re-license this specific piece of code to you free of charge.
*/

/* Copyright (C) 2005 by Michal Kvasnica (michal.kvasnica@stuba.sk) 
   Revised in 2012-2013 by Martin Herceg (herceg@control.ee.ethz.ch)    
*/


/*  This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
*/ 

/* Generated by MPT 3.1.8 */ 

/* main evaluation function using sequential search */
void ectrl( float *X, float *U){
    int ix, jx, ic, nc, isinside;
    unsigned long ireg, abspos, iregmin, region;
    float hx, sx;

    abspos = 0;
    region = 0;
    iregmin = 0;

    for (ireg=0; ireg<MPT_NR; ireg++) {

        isinside = 1;
        nc = pgm_read_word(&(MPT_NC[ireg]));
        for (ic=0; ic<nc; ic++) {
            hx = 0;
            for (ix=0; ix<MPT_DOMAIN; ix++) {
                hx += pgm_read_float(&(MPT_A[abspos*MPT_DOMAIN+ic*MPT_DOMAIN+ix]))*X[ix];
            }
            if ((hx - pgm_read_float(&(MPT_B[abspos+ic]))) > MPT_ABSTOL) {
                /* constraint is violated, continue with next region */
                isinside = 0;
                break;
            } 
        }
        abspos = abspos + pgm_read_word(&(MPT_NC[ireg]));
    }
    for (ix=0; ix<MPT_RANGE; ix++) {
        sx = 0;
        for (jx=0; jx<MPT_DOMAIN; jx++) {
            sx += pgm_read_float(&(MPT_F[iregmin*MPT_DOMAIN*MPT_RANGE + ix*MPT_DOMAIN + jx]))*X[jx];
        }
        U[ix] = sx + pgm_read_float(&(MPT_G[iregmin*MPT_RANGE + ix]));
    }
}
